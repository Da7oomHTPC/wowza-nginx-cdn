#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;


    lua_shared_dict cassandra 1m; # shm storing cluster information
    lua_code_cache on;            # ensure the upvalue is preserved beyond a single request

    init_by_lua_block {
        local dvr = require "dvr"
        local dc_rr = require "resty.cassandra.policies.lb.dc_rr"
        local policy = dc_rr.new("dc1")


        dvr.init_cluster {
            shm = "cassandra",
            contact_points = {"192.168.1.184"},
            keyspace = "dvr",
            protocol_version = 4,
            lb_policy = policy
        }
    }

    map $uri $basename {
        ~/(?<captured_basename>[^/]*)$ $captured_basename;
    }

    map $uri $basepath {
        ~/(?<captured_basepath>.*)/playlist\.m3u8$ $captured_basepath;
    }

    server {
        listen       80;
        server_name  _;

        gzip on;
        gzip_types application/vnd.apple.mpegurl;

        #access_log  logs/host.access.log  main;

        location / {

	          client_max_body_size 20m;

	          autoindex on;
            root   /tmp/wwwroot;

	          client_body_temp_path /tmp/wwwtmp;
    	      dav_methods PUT DELETE MKCOL COPY MOVE;
            create_full_put_path  on;
	          dav_access all:rw;

        }

        location /dvr/bnt1_480p_playlist_all.m3u8 {

            expires 1s;
            add_header Cache-Control public;

            content_by_lua_block {

                local dvr = require "dvr"
                local cassandra = require "cassandra"

		            local max_dvr_seconds = 30
		            local max_dvr_date = os.time()
		            max_dvr_date = max_dvr_date - max_dvr_seconds

		            local qry = 'select fake,playlist from bnt1_480p_playlist_all WHERE fake=1 AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\') limit 1'

                local rows, err = dvr.execute(qry,nil,{consistency=cassandra.consistencies.local_one})

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve playlist: ', err)
                    return ngx.exit(500)
                end

               ngx.say(rows[1].playlist)
            }
        }


	      location ~ /dvr/(.*\.ts)$ {

	          set $ts_file $basename;

            expires 4h;
            add_header Cache-Control public;

            content_by_lua_block {

                local dvr = require "dvr"
                local cassandra = require "cassandra"

		            local max_dvr_seconds = 60 * 60 * 8
		            local max_dvr_date = os.time()
		            max_dvr_date = max_dvr_date - max_dvr_seconds

		            local qry = 'SELECT chunk_content FROM bnt1_480p_chunk_content WHERE chunk_name=\''.. ngx.var.ts_file ..'\' AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\')'

                local rows, err = dvr.execute(qry,nil,{consistency=cassandra.consistencies.local_one})

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve chunk: ', err)
                    return ngx.exit(500)
                end

                ngx.print(rows[1].chunk_content)
            }
        }
    }
}

