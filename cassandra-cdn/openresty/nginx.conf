#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;


    lua_shared_dict cassandra 1m; # shm storing cluster information
    lua_code_cache on;            # ensure the upvalue is preserved beyond a single request

    init_by_lua_block {
        local dvr = require "dvr"
        local dc_rr = require "resty.cassandra.policies.lb.dc_rr"
        local policy = dc_rr.new("sof1")


        dvr.init_cluster {
            shm = "cassandra",
            contact_points = {"93.123.36.180"},
            keyspace = "dvr",
            protocol_version = 4,
            lb_policy = policy
        }
    }

    map $uri $basename {
        ~/(?<captured_basename>[^/]*)$ $captured_basename;
    }

    # url format of playlist: app/tv channel name/start time/end time/variant playlist or specific bitrate
    map $uri $_app {
        ~/(?<app>[a-z0-9_\-]+)/(?<tv>[a-z0-9_\-]+)/(?<bitrate>[0-9]+)/(?<start>[0-9]+)/(?<finish>[0-9]+)/[a-z0-9_\-]+\.(m3u8|ts)$ $app;
    }

    server {
        listen       80;
        server_name  _;

        gzip on;
        gzip_types application/vnd.apple.mpegurl;

        #access_log  logs/host.access.log  main;

        location / {

            root   /tmp/wwwroot;

        }

        location ~ /([a-z0-9_\-]+\.m3u8)$ {

            # populate needed variables
            set $req $_app;
            set $playlist_file $basename;

            expires 1s;
            add_header Cache-Control public;

            content_by_lua_block {

                function explode(div,str) -- credit: http://richard.warburton.it
          	    if (div=='') then return false end
          	    local pos,arr = 0,{}
                    -- for each divider found
                    for st,sp in function() return string.find(str,div,pos,true) end do
                        table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider
                        pos = sp + 1 -- Jump past current divider
                    end
                    table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider
                    return arr
                end

                local dvr = require "dvr"
                local cassandra = require "cassandra"

                -- seconds from now to look back for chunks in database - some kind of
                -- cache in case of encoder restart and network issues
                local max_chunk_creation_time_in_seconds = 60

                local app = ngx.var.app
                local tv = ngx.var.tv
                local bitrate = tonumber(ngx.var.bitrate)
                local start = tonumber(ngx.var.start)
                local finish = tonumber(ngx.var.finish)

                local table_chunk_info = app .. '_' .. tv .. '_' .. bitrate .. '_chunk_info'
                local table_variant_info = 'variant_info'

                -- end of line string
                local eol = '\n'
                local qry = nil
                local playlist_type = ''
                local variant = ''
                local extm3u = '#EXTM3U'
                local m3uversion = '#EXT-X-VERSION:3'
                local m3ucache = '#EXT-X-ALLOW-CACHE:YES'

                local chunks_in_playlist = 3
                local date = os.time()
                live_date = date - max_chunk_creation_time_in_seconds

                -- determine playlist type: VARIANT, LIVE, EVENT or VOD
                if bitrate == 0 then
                    playlist_type = 'variant'
                    qry = 'SELECT bitrate, codecs, resolution  FROM ' .. table_variant_info .. ' WHERE app=\'' .. app .. '\' AND tv=\'' .. tv .. '\' ALLOW FILTERING'
                else
                    if start == 0 and finish == 0 then
                        playlist_type = 'live'
                        qry = 'SELECT fake, chunk_duration, chunk_name FROM ' .. table_chunk_info .. ' WHERE time_id>maxTimeuuid(\'' .. os.date("%Y-%m-%d %X", live_date) .. '\') LIMIT ' .. chunks_in_playlist .. ' ALLOW FILTERING'
                    else
                        -- implement some kind of buffering
                        if start >= 0 and finish > start and live_date <= finish then
                            playlist_type = 'event'
                            qry = 'SELECT fake, chunk_duration, chunk_name FROM ' .. table_chunk_info .. ' WHERE time_id>maxTimeuuid(\'' .. os.date("%Y-%m-%d %X", start) .. '\') AND time_id<maxTimeuuid(\'' .. os.date("%Y-%m-%d %X", live_date) .. '\') ALLOW FILTERING'
                        else
                            playlist_type = 'vod'
                            qry = 'SELECT fake, chunk_duration, chunk_name FROM ' .. table_chunk_info .. ' WHERE time_id>maxTimeuuid(\'' .. os.date("%Y-%m-%d %X", start) .. '\') AND time_id<maxTimeuuid(\'' .. os.date("%Y-%m-%d %X", finish) .. '\') ALLOW FILTERING'
                        end
                    end
                end

                if qry == nil then
                    ngx.log(ngx.ERR, 'NETERRA.LOG: bad query parameters. ', err)
                    return ngx.exit(400)
                end

                local rows, err = dvr.execute(qry,nil,{consistency=cassandra.consistencies.local_one})

                if not rows then
                   ngx.log(ngx.ERR, 'NETERRA.LOG: could not retrieve playlist: ', err)
                   return ngx.exit(400)
                end


                if playlist_type == 'variant' then

                     variant = extm3u .. eol .. m3uversion

                     for i, row in ipairs(rows) do
                        variant = variant .. eol .. '#EXT-X-STREAM-INF:BANDWIDTH=' .. rows[i].bitrate .. ',CODECS=' .. rows[i].codecs .. ',RESOLUTION=' .. rows[i].resolution .. eol .. '/' .. app .. '/' .. tv .. '/' .. rows[i].bitrate .. '/' .. start .. '/' .. finish .. '/chunklist.m3u8'
                    end

                    ngx.say(variant)

                else

                    -- generate m3u8 live/vod/event playlist
                    local playlist_live_tmp1 = ''
                    local playlist_live_tmp2 = ''
                    local first_cunk = 'true'
                    local first_chunk_num = 0
                    local targetduration = 0
                    local first_chunk_num_tmp1 = {}
                    local first_chunk_num_tmp2 = {}

                    for i, row in ipairs(rows) do
                        if first_cunk == 'true' then
                            first_chunk_num_tmp1 = explode('_', rows[i].chunk_name)
                            -- explode last element of previous table
                            first_chunk_num_tmp2 = explode('.ts', first_chunk_num_tmp1[table.getn(first_chunk_num_tmp1)])
                            first_chunk_num = first_chunk_num_tmp2[1]
                            targetduration=math.ceil(rows[i].chunk_duration)
                            first_cunk = 'false'
                        end 

                        playlist_live_tmp1 = playlist_live_tmp1 .. eol .. '#EXTINF:' .. rows[i].chunk_duration .. ',' .. eol .. rows[i].chunk_name

                    end

                    playlist_live_tmp2 = extm3u .. eol .. m3uversion .. eol .. m3ucache .. eol .. '#EXT-X-TARGETDURATION:' .. targetduration .. eol .. '#EXT-X-MEDIA-SEQUENCE:' .. first_chunk_num

                    playlist_live = playlist_live_tmp2 .. playlist_live_tmp1

                    if playlist_type == 'vod' then
                        playlist_live = playlist_live .. eol .. '#EXT-X-ENDLIST'
                    end

                    ngx.say(playlist_live)
                end

            }
        }


        location ~ /([a-z0-9_\-]+\.ts)$ {

            # populate needed variables
            set $req $_app;
            set $ts_file $basename;

            expires 24h;
            add_header Cache-Control public;

            content_by_lua_block {

                local dvr = require "dvr"
                local cassandra = require "cassandra"

                local table_chunk_content = ngx.var.app .. '_' .. ngx.var.tv .. '_' .. ngx.var.bitrate .. '_chunk_content'

                local start = ngx.var.start
                local finish = ngx.var.finish

                local max_dvr_seconds = 60 * 60 * 30
                local max_dvr_date = os.time()
                max_dvr_date = max_dvr_date - max_dvr_seconds

                local qry = 'SELECT chunk_content FROM ' .. table_chunk_content .. ' WHERE chunk_name=\''.. ngx.var.ts_file ..'\' AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\')'

                local rows, err = dvr.execute(qry,nil,{consistency=cassandra.consistencies.local_one})

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve chunk: ', err)
                    return ngx.exit(400)
                end

                ngx.print(rows[1].chunk_content)
            }
        }
    }
}
