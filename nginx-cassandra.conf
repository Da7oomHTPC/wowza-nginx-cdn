#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;



  lua_shared_dict cassandra 1m; # shm storing cluster information
  lua_code_cache on;            # ensure the upvalue is preserved beyond a single request

  init_by_lua_block {
    local dvr = require "dvr"
    dvr.init_cluster {
      shm = "cassandra", -- defined in http block
      contact_points = {"127.0.0.1"},
      keyspace = "dvr",
      protocol_version = 4
    }
  }




    map $uri $basename {
        ~/(?<captured_basename>[^/]*)$ $captured_basename;
    }

    server {
        listen       80;
        server_name  _;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {

	client_max_body_size 20m;

	    autoindex on;
            root   /tmp/wwwroot;

	    client_body_temp_path /tmp/wwwtmp;

    	    dav_methods PUT DELETE MKCOL COPY MOVE;

            create_full_put_path  on;

	    dav_access all:rw;

        }

	location /dvr/bnt1_480p_playlist_all.m3u8 {
            content_by_lua_block {

                local dvr = require "dvr"

		local max_dvr_seconds = 30
		local max_dvr_date = os.time()
		max_dvr_date = max_dvr_date - max_dvr_seconds

		local qry = 'select fake,playlist from bnt1_480p_playlist_all WHERE fake=1 AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\') limit 1'

                local rows, err = dvr.execute(qry,nil,{consistency=0x000a})

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve playlist: ', err)
                    return ngx.exit(500)
                end

                ngx.say(rows[1].playlist)
            }
	}


	location ~ /dvr/(.*\.ts)$ {

	    set $ts_file $basename;

            content_by_lua_block {

                local dvr = require "dvr"

		local max_dvr_seconds = 60 * 60 * 8
		local max_dvr_date = os.time()
		max_dvr_date = max_dvr_date - max_dvr_seconds

		local qry = 'SELECT chunk_content FROM bnt1_480p_chunk_content WHERE chunk_name=\''.. ngx.var.ts_file ..'\' AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\')'

                local rows, err = dvr.execute(qry,nil,{consistency=0x000a})

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve chunk: ', err)
                    return ngx.exit(500)
                end

                ngx.print(rows[1].chunk_content)
            }
	}

    }
}

