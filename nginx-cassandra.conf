#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    lua_shared_dict cassandra 1m;

    map $uri $basename {
        ~/(?<captured_basename>[^/]*)$ $captured_basename;
    }

    server {
        listen       80;
        server_name  _;
	
	gzip on;
        gzip_types application/vnd.apple.mpegurl;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {

	client_max_body_size 20m;

	    autoindex on;
            root   /tmp/wwwroot;

	    client_body_temp_path /tmp/wwwtmp;

    	    dav_methods PUT DELETE MKCOL COPY MOVE;

            create_full_put_path  on;

	    dav_access all:rw;

        }

	location /dvr/bnt1_480p_playlist_all.m3u8 {
	
	    expires 1s;
	    add_header Cache-Control public;
	    
            content_by_lua_block {
                local Cluster = require 'resty.cassandra.cluster'
		local dc_rr = require "resty.cassandra.policies.lb.dc_rr"
		local policy = dc_rr.new("sof1")

                local cluster, err = Cluster.new {
                    shm = 'cassandra',
                    contact_points = {'192.168.8.184'},
		    lb_policy = policy,
                    keyspace = 'dvr'
                }

                if not cluster then
                    ngx.log(ngx.ERR, 'could not create cluster: ', err)
                    return ngx.exit(500)
                end

		local max_dvr_seconds = 30
		local max_dvr_date = os.time()
		max_dvr_date = max_dvr_date - max_dvr_seconds

		local qry = 'select fake,playlist from bnt1_480p_playlist_all WHERE fake=1 AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\') limit 1'

                local rows, err = cluster:execute(qry)

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve playlist: ', err)
                    return ngx.exit(500)
                end

                ngx.say(rows[1].playlist)
            }
	}


	location ~ /dvr/(.*\.ts)$ {

	    set $ts_file $basename;
	    
	    expires 4h;
	    add_header Cache-Control public;

            content_by_lua_block {
                local Cluster = require 'resty.cassandra.cluster'
		local dc_rr = require "resty.cassandra.policies.lb.dc_rr"
		local policy = dc_rr.new("sof1")

                local cluster, err = Cluster.new {
                    shm = 'cassandra',
                    contact_points = {'192.168.8.184'},
		    lb_policy = policy,
                    keyspace = 'dvr'
                }

                if not cluster then
                    ngx.log(ngx.ERR, 'could not create cluster: ', err)
                    return ngx.exit(500)
                end

		local max_dvr_seconds = 60 * 60 * 4
		local max_dvr_date = os.time()
		max_dvr_date = max_dvr_date - max_dvr_seconds

		local qry = 'SELECT chunk_content FROM bnt1_480p_chunk_content WHERE chunk_name=\''.. ngx.var.ts_file ..'\' AND time_id>maxTimeuuid(\''.. os.date("%Y-%m-%d %X", max_dvr_date) ..'\')'

                local rows, err = cluster:execute(qry)

                if not rows then
                    ngx.log(ngx.ERR, 'could not retrieve chunk: ', err)
                    return ngx.exit(500)
                end

                ngx.print(rows[1].chunk_content)
            }
	}

    }
}
